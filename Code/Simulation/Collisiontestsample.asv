function isCollision = CheckCollision(robot, sphereCenter, radius)
% function isCollision = CheckCollision(robot, sphereCenter, radius)

%     pause(0.1)
    tr = robot.fkine(robot.getpos);
    endEffectorToCenterDist = sqrt(sum((sphereCenter-tr(1:3,4)').^2));
    if endEffectorToCenterDist <= radius
%         disp('A collision detected');
        isCollision = 1;
    else
%         disp(['SAFE: End effector to sphere centre distance (', num2str(endEffectorToCenterDist), 'm) is more than the sphere radius, ' num2str(radius), 'm']);
        isCollision = 0;
    end

end

function createCollision(robot,q)
    centerPoint = [0,0,0];
    radii = [1,0.5,0.5];
    [X,Y,Z] = ellipsoid( centerPoint(1), centerPoint(2), centerPoint(3), radii(1),
    radii(2), radii(3) );
    for i = 1:4
        robot.points{i} = [X(:),Y(:),Z(:)];
        warning off
        robot.faces{i} = delaunay(robot.points{i});
        warning on;
    end
    
    tr = robot.fkine(q);
    cubePointsAndOnes = [inv(tr) * [cubePoints,ones(size(cubePoints,1),1)]']';
    updatedCubePoints = cubePointsAndOnes(:,1:3);
    algebraicDist = GetAlgebraicDist(updatedCubePoints, centerPoint, radii);
    pointsInside = find(algebraicDist < 1);
    display(['2.9: There are now ', num2str(size(pointsInside,1)),' points inside']);
end
